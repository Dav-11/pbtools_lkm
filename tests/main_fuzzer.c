/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by asn1tools version 0.145.2 Thu Jan 24 07:56:59 2019.
 */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "files/c_source/address_book.h"

static void assert_first_encode(ssize_t res)
{
    if (res < 0) {
        printf("First encode failed with %ld.\n", res);
        __builtin_trap();
    }
}

static void assert_second_decode(ssize_t res)
{
    if (res < 0) {
        printf("Second decode failed with %ld.\n", res);
        __builtin_trap();
    }
}

static void assert_second_decode_data(const void *decoded_p,
                                      const void *decoded_2_p,
                                      size_t size)
{
    int i;
    const uint8_t *u8_decoded_p;
    const uint8_t *u8_decoded_2_p;

    u8_decoded_p = decoded_p;
    u8_decoded_2_p = decoded_2_p;
    
    if (memcmp(decoded_p, decoded_2_p, size) != 0) {
        printf("Second decode data does not match first decoded data.\n");

        for (i = 0; i < size; i++) {
            printf("0x%02x 0x%02x ", u8_decoded_p[i], u8_decoded_2_p[i]);

            if (u8_decoded_p[i] != u8_decoded_2_p[i]) {
                printf("- differ");
            }
            
            printf("\n");
        }
        
        __builtin_trap();
    }
}

static void assert_second_encode(ssize_t res, ssize_t res2)
{
    if (res != res2) {
        printf("Second encode result %ld does not match first pack "
               "result %ld.\n",
               res,
               res2);
        __builtin_trap();
    }
}

static void assert_second_encode_data(const uint8_t *encoded_p,
                                      const uint8_t *encoded2_p,
                                      ssize_t size)
{
    ssize_t i;

    if (memcmp(encoded_p, encoded2_p, size) != 0) {
        for (i = 0; i < size; i++) {
            printf("[%04ld]: 0x%02x 0x%02x\n", i, encoded_p[i], encoded2_p[i]);
        }

        __builtin_trap();
    }
}


static void test_address_book(
    const uint8_t *encoded_p,
    size_t size)
{
    ssize_t res;
    /* ssize_t res_2; */
    ssize_t i;
    uint8_t encoded[size + 1];
    /* uint8_t encoded_2[size + 1]; */
    uint8_t workspace[4096];
    /* uint8_t workspace_2[4096]; */
    struct address_book_address_book_t *decoded_p;
    /* struct address_book_address_book_t *decoded_2_p; */

    decoded_p = address_book_address_book_new(&workspace[0],
                                              sizeof(workspace));

    if (decoded_p == NULL) {
        return;
    }

    res = address_book_address_book_decode(
        decoded_p,
        encoded_p,
        size);

    if (res >= 0) {
        res = address_book_address_book_encode(
            decoded_p,
            &encoded[0],
            sizeof(encoded));

        assert_first_encode(res);

        /* decoded_p = address_book_address_book_new(&workspace_2[0], */
        /*                                           sizeof(workspace_2)); */

        /* if (decoded_p == NULL) { */
        /*     return; */
        /* } */

        /* res_2 = address_book_address_book_decode( */
        /*     decoded_p, */
        /*     &encoded[0], */
        /*     res); */

        /* assert_second_decode(res_2); */
        /* assert_second_decode_data(&workspace[0], */
        /*                           &workspace_2[0], */
        /*                           sizeof(workspace)); */

        /* res_2 = address_book_address_book_encode( */
        /*     decoded_p, */
        /*     &encoded_2[0], */
        /*     sizeof(encoded_2)); */

        /* assert_second_encode(res, res_2); */
        /* assert_second_encode_data(&encoded[0], &encoded_2[0], res); */
    }
}

int LLVMFuzzerTestOneInput(const uint8_t *data_p, size_t size)
{
    test_address_book(data_p, size);

    return (0);
}
