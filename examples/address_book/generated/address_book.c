/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by pbtools version 0.1.0 Thu Jan 24 08:14:06 2019.
 */

#include <string.h>
#include <stdlib.h>

#include "address_book.h"

struct encoder_t {
    int number_of_bytes;
};

static void encoder_init(struct encoder_t *self_p)
{
    self_p->number_of_bytes = 0;
}

static ssize_t encoder_get_result(struct encoder_t *self_p)
{
    return (-1);
}

void address_book_person_free(struct address_book_person_t *person_p)
{
    free(person_p);
}

struct address_book_person_phone_number_t *address_book_person_phone_number_alloc(void)
{
    struct address_book_person_phone_number_t *phone_number_p;

    phone_number_p = malloc(sizeof(*phone_number_p));

    if (phone_number_p != NULL) {
        phone_number_p->number_p = strdup("");

        if (phone_number_p->number_p == NULL) {
            goto err;
        }

        phone_number_p->type = address_book_person_phone_type_mobile_e;
    }

    return (phone_number_p);

 err:
    free(phone_number_p);

    return (NULL);
}

struct address_book_person_t *address_book_person_alloc(void)
{
    struct address_book_person_t *person_p;

    person_p = malloc(sizeof(*person_p));

    if (person_p != NULL) {
        person_p->name_p = strdup("");

        if (person_p->name_p == NULL) {
            goto err;
        }

        person_p->id = 0;
        person_p->email_p = strdup("");

        if (person_p->email_p == NULL) {
            goto err;
        }

        person_p->phones.length = 0;
    }

    return (person_p);

 err:
    free(person_p);

    return (NULL);
}

struct address_book_adderss_book_t *address_book_adderss_book_alloc(void)
{
    struct address_book_adderss_book_t *address_book_p;

    address_book_p = malloc(sizeof(*address_book_p));

    if (address_book_p != NULL) {
        address_book_p->people.length = 0;
        address_book_p->people.elems_pp = malloc(1);
    }

    return (address_book_p);
}

void address_book_adderss_book_free(struct address_book_adderss_book_t *address_book_p)
{
    int i;

    if (address_book_p->people.length > 0) {
        for (i = 0; i < address_book_p->people.length; i++) {
            address_book_person_free(address_book_p->people.array_pp[i]);
        }

        free(address_book_p->people.array_pp);
    }

    free(address_book_p);
}

struct address_book_person_t *address_book_adderss_book_people_add(
    struct address_book_adderss_book_t *address_book_p)
{
    address_book_p->people.length++;
    address_book_p->people.elems_pp = realloc(
        address_book_p->people.elems_pp,
        sizeof(*address_book_p->people.elems_pp) * address_book_p->people.length);
    address_book_p->people.elems_pp[address_book_p->people.length - 1] = person_p;

    return (0);
}

int address_book_adderss_book_people_length(
    struct address_book_adderss_book_t *address_book_p)
{
    return (address_book_p->people.length);
}

struct address_book_person_t *address_book_adderss_book_people_get(
    struct address_book_adderss_book_t *address_book_p,
    int index)
{
    return (NULL);
}

int address_book_person_set_name(
    struct address_book_person_t *person_p,
    const char *value_p)
{
    if (person_p->name_p != NULL) {
        free(person_p->name_p);
    }

    person_p->name_p = strdup(value_p);

    if (person_p->name_p == NULL) {
        return (-1);
    }

    return (0);
}

const char *address_book_person_get_name(
    struct address_book_person_t *person_p)
{
    return (person_p->name_p);
}

int address_book_person_set_id(
    struct address_book_person_t *person_p,
    int32_t value)
{
    person_p->id = value;

    return (0);
}

int32_t address_book_person_get_id(
    struct address_book_person_t *person_p)
{
    return (person_p->id);
}

int address_book_person_set_email(
    struct address_book_person_t *person_p,
    const char *value_p)
{
    if (person_p->email_p != NULL) {
        free(person_p->email_p);
    }

    person_p->email_p = strdup(value_p);

    if (person_p->email_p == NULL) {
        return (-1);
    }

    return (0);
}

const char *address_book_person_get_email(
    struct address_book_person_t *person_p)
{
    return (person_p->email_p);
}

struct address_book_person_phone_number_t *address_book_person_phones_add(
    struct address_book_person_t *person_p)
{
    struct address_book_person_phone_number_t *phone_number_p;

    phone_number_p = address_book_person_phone_number_alloc();

    if (phone_number_p != NULL) {
        if (person_p->is_phones_present) {
            person_p->phones.array_pp = realloc(
                person_p->phones.array_pp,
                sizeof(*person_p->phones.array_pp) * (person_p->phones.length + 1));
        } else {
            person_p->phones.array_pp = malloc(
                sizeof(*person_p->phones.array_pp));
            person_p->phones.length = 0;
        }

        person_p->phones.array_pp[person_p->phones.length] = phone_number_p;
        person_p->phones.length++;
    }

    return (phone_number_p);
}

int address_book_person_phones_length(
    struct address_book_person_t *person_p)
{
    return (-1);
}

struct address_book_person_phone_number_t *address_book_person_phones_get(
    struct address_book_person_t *person_p,
    int index)
{
    return (NULL);
}

int address_book_person_phone_number_set_number(
    struct address_book_person_phone_number_t *phone_number_p,
    const char *value_p)
{
    if (phone_number_p->is_number_present) {
        free(phone_number_p->number_p);
        phone_number_p->is_number_present = false;
    }

    phone_number_p->number_p = strdup(value_p);

    if (phone_number_p->number_p == NULL) {
        return (-1);
    }

    phone_number_p->is_number_present = true;

    return (0);
}

int address_book_person_phone_number_set_type(
    struct address_book_person_phone_number_t *phone_number_p,
    enum address_book_person_phone_type_e value)
{
    phone_number_p->type = value;

    return (0);
}

const char *address_book_person_phone_number_get_number(
    struct address_book_person_phone_number_t *phone_number_p)
{
    return (NULL);
}

enum address_book_person_phone_type_e address_book_person_phone_number_get_type(
    struct address_book_person_phone_number_t *phone_number_p)
{
    return (address_book_person_phone_type_mobile_e);
}

void address_book_person_encode_inner(
    struct encoder_t *encoder_p,
    struct address_book_person_t *person_p)
{
}

int address_book_adderss_book_encode(
    struct address_book_adderss_book_t *address_book_p,
    uint8_t **encoded_pp)
{
    struct encoder_t encoder;
    int i;

    encoder_init(&encoder);

    if (address_book_p->is_people_present) {
        for (i = 0; i < address_book_p->people.length; i++) {
            address_book_person_encode_inner(&encoder,
                                             address_book_p->people.array_pp[i]);
        }
    }

    return (encoder_get_result(&encoder));
}

int address_book_adderss_book_decode(
    const uint8_t *encoded_p,
    struct address_book_adderss_book_t **address_book_pp)
{
    return (-1);
}
